// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package com.nekopiano.scala.scalaxb.y.items
    
/**
usage:
val obj = scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.Foo](node)
val document = scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.Foo](obj, "foo", com.nekopiano.scala.scalaxb.y.items.defaultScope)
**/
object `package` extends XMLProtocol { }

trait XMLProtocol extends scalaxb.XMLStandardTypes {
  val defaultScope = scalaxb.toScope(Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val ItemsAtomictypeTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.AtomictypeType] = new DefaultItemsAtomictypeTypeFormat {}
  implicit lazy val ItemsAtomictypesTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.AtomictypesType] = new DefaultItemsAtomictypesTypeFormat {}
  implicit lazy val ItemsTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.Type] = new DefaultItemsTypeFormat {}
  implicit lazy val ItemsCollectiontypeTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.CollectiontypeType] = new DefaultItemsCollectiontypeTypeFormat {}
  implicit lazy val ItemsCollectiontypesTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.CollectiontypesType] = new DefaultItemsCollectiontypesTypeFormat {}
  implicit lazy val ItemsDeploymentTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.DeploymentType] = new DefaultItemsDeploymentTypeFormat {}
  implicit lazy val ItemsRelationTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.RelationType] = new DefaultItemsRelationTypeFormat {}
  implicit lazy val ItemsRelationsTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.RelationsType] = new DefaultItemsRelationsTypeFormat {}
  implicit lazy val ItemsCardinalityFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.Cardinality] = new DefaultItemsCardinalityFormat {}
  implicit lazy val ItemsCollectiontypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.Collectiontype] = new DefaultItemsCollectiontypeFormat {}
  implicit lazy val ItemsRelationElementTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.RelationElementType] = new DefaultItemsRelationElementTypeFormat {}
  implicit lazy val ItemsEnumtypeTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.EnumtypeType] = new DefaultItemsEnumtypeTypeFormat {}
  implicit lazy val ItemsEnumtypesTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.EnumtypesType] = new DefaultItemsEnumtypesTypeFormat {}
  implicit lazy val ItemsIndexTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.IndexType] = new DefaultItemsIndexTypeFormat {}
  implicit lazy val ItemsIndexKeyTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.IndexKeyType] = new DefaultItemsIndexKeyTypeFormat {}
  implicit lazy val ItemsAttributeTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.AttributeType] = new DefaultItemsAttributeTypeFormat {}
  implicit lazy val ItemsAttributeModelTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.AttributeModelType] = new DefaultItemsAttributeModelTypeFormat {}
  implicit lazy val ItemsItemModelTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.ItemModelType] = new DefaultItemsItemModelTypeFormat {}
  implicit lazy val ItemsModelConstructorTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.ModelConstructorType] = new DefaultItemsModelConstructorTypeFormat {}
  implicit lazy val ItemsModelMethodTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.ModelMethodType] = new DefaultItemsModelMethodTypeFormat {}
  implicit lazy val ItemsCustomPropertiesTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.CustomPropertiesType] = new DefaultItemsCustomPropertiesTypeFormat {}
  implicit lazy val ItemsCustomPropertyTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.CustomPropertyType] = new DefaultItemsCustomPropertyTypeFormat {}
  implicit lazy val ItemsAttributesTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.AttributesType] = new DefaultItemsAttributesTypeFormat {}
  implicit lazy val ItemsIndexesTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.IndexesType] = new DefaultItemsIndexesTypeFormat {}
  implicit lazy val ItemsItemtypeTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.ItemtypeType] = new DefaultItemsItemtypeTypeFormat {}
  implicit lazy val ItemsItemtypesTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.ItemtypesType] = new DefaultItemsItemtypesTypeFormat {}
  implicit lazy val ItemsTypeGroupTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.TypeGroupType] = new DefaultItemsTypeGroupTypeFormat {}
  implicit lazy val ItemsItemsFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.Items] = new DefaultItemsItemsFormat {}
  implicit lazy val ItemsMaptypeTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.MaptypeType] = new DefaultItemsMaptypeTypeFormat {}
  implicit lazy val ItemsMaptypesTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.MaptypesType] = new DefaultItemsMaptypesTypeFormat {}
  implicit lazy val ItemsModifiersTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.ModifiersType] = new DefaultItemsModifiersTypeFormat {}
  implicit lazy val ItemsTypeTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.TypeType] = new DefaultItemsTypeTypeFormat {}
  implicit lazy val ItemsPersistenceTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.PersistenceType] = new DefaultItemsPersistenceTypeFormat {}
  implicit lazy val ItemsColumntypeTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.ColumntypeType] = new DefaultItemsColumntypeTypeFormat {}
  implicit lazy val ItemsValueTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.ValueType] = new DefaultItemsValueTypeFormat {}
  implicit lazy val ItemsEnumModelTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.EnumModelType] = new DefaultItemsEnumModelTypeFormat {}
  implicit lazy val ItemsEnumValueTypeFormat: scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.EnumValueType] = new DefaultItemsEnumValueTypeFormat {}

  trait DefaultItemsAtomictypeTypeFormat extends scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.AtomictypeType] with scalaxb.CanWriteChildNodes[com.nekopiano.scala.scalaxb.y.items.AtomictypeType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.nekopiano.scala.scalaxb.y.items.AtomictypeType] = seq match {
      case node: scala.xml.Node => Right(com.nekopiano.scala.scalaxb.y.items.AtomictypeType(scalaxb.fromXML[String]((node \ "@class"), scalaxb.ElemName(node) :: stack),
        (node \ "@autocreate").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack) },
        (node \ "@generate").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack) },
        (node \ "@extends").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.AtomictypeType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "class", __obj.classValue.toString, attr)
      if (__obj.autocreate.toString != "true") attr = scala.xml.Attribute(null, "autocreate", __obj.autocreate.toString, attr)
      if (__obj.generate.toString != "true") attr = scala.xml.Attribute(null, "generate", __obj.generate.toString, attr)
      __obj.extendsValue foreach { x => attr = scala.xml.Attribute(null, "extends", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.AtomictypeType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultItemsAtomictypesTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.AtomictypesType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("atomictypesType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.AtomictypesType] =
      phrase(rep(scalaxb.ElemName(None, "atomictype")) ^^
      { case p1 =>
      com.nekopiano.scala.scalaxb.y.items.AtomictypesType(p1.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.AtomictypeType](_, scalaxb.ElemName(node) :: stack) }: _*) })
    
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.AtomictypesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.atomictype flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.AtomictypeType](_, None, Some("atomictype"), __scope, false) })
  }

  def buildItemsTypeFormat = new DefaultItemsTypeFormat {}
  trait DefaultItemsTypeFormat extends scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.Type] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.nekopiano.scala.scalaxb.y.items.Type] = seq match {
      case elem: scala.xml.Elem => Right(com.nekopiano.scala.scalaxb.y.items.Type.fromString(elem.text, elem.scope))
      case _ => Right(com.nekopiano.scala.scalaxb.y.items.Type.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.nekopiano.scala.scalaxb.y.items.Type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }
  trait DefaultItemsCollectiontypeTypeFormat extends scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.CollectiontypeType] with scalaxb.CanWriteChildNodes[com.nekopiano.scala.scalaxb.y.items.CollectiontypeType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.nekopiano.scala.scalaxb.y.items.CollectiontypeType] = seq match {
      case node: scala.xml.Node => Right(com.nekopiano.scala.scalaxb.y.items.CollectiontypeType(scalaxb.fromXML[String]((node \ "@code"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@elementtype"), scalaxb.ElemName(node) :: stack),
        (node \ "@autocreate").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack) },
        (node \ "@generate").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack) },
        (node \ "@type").headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.Type](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.Type](scala.xml.Text("collection"), scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.CollectiontypeType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "code", __obj.code.toString, attr)
      attr = scala.xml.Attribute(null, "elementtype", __obj.elementtype.toString, attr)
      if (__obj.autocreate.toString != "true") attr = scala.xml.Attribute(null, "autocreate", __obj.autocreate.toString, attr)
      if (__obj.generate.toString != "true") attr = scala.xml.Attribute(null, "generate", __obj.generate.toString, attr)
      if (__obj.typeValue.toString != "collection") attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.CollectiontypeType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultItemsCollectiontypesTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.CollectiontypesType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("collectiontypesType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.CollectiontypesType] =
      phrase(rep(scalaxb.ElemName(None, "collectiontype")) ^^
      { case p1 =>
      com.nekopiano.scala.scalaxb.y.items.CollectiontypesType(p1.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.CollectiontypeType](_, scalaxb.ElemName(node) :: stack) }: _*) })
    
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.CollectiontypesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.collectiontype flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.CollectiontypeType](_, None, Some("collectiontype"), __scope, false) })
  }

  trait DefaultItemsDeploymentTypeFormat extends scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.DeploymentType] with scalaxb.CanWriteChildNodes[com.nekopiano.scala.scalaxb.y.items.DeploymentType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.nekopiano.scala.scalaxb.y.items.DeploymentType] = seq match {
      case node: scala.xml.Node => Right(com.nekopiano.scala.scalaxb.y.items.DeploymentType(scalaxb.fromXML[String]((node \ "@table"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Short]((node \ "@typecode"), scalaxb.ElemName(node) :: stack),
        (node \ "@propertytable").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.DeploymentType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "table", __obj.table.toString, attr)
      attr = scala.xml.Attribute(null, "typecode", __obj.typecode.toString, attr)
      __obj.propertytable foreach { x => attr = scala.xml.Attribute(null, "propertytable", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.DeploymentType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultItemsRelationTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.RelationType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("relationType")

    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.RelationType] =
      phrase(optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "description")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "deployment")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.DeploymentType](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "sourceElement")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.RelationElementType](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ~ 
      ((scalaxb.ElemName(None, "targetElement")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.RelationElementType](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 =>
      com.nekopiano.scala.scalaxb.y.items.RelationType(Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        Seq(p6),
        p7.toList,
        Seq(p8),
        p9.toList),
        scalaxb.fromXML[String]((node \ "@code"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Boolean]((node \ "@localized"), scalaxb.ElemName(node) :: stack),
        (node \ "@deployment").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@autocreate").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack) },
        (node \ "@generate").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.RelationType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "code", __obj.code.toString, attr)
      attr = scala.xml.Attribute(null, "localized", __obj.localized.toString, attr)
      __obj.deployment foreach { x => attr = scala.xml.Attribute(null, "deployment", x.toString, attr) }
      if (__obj.autocreate.toString != "true") attr = scala.xml.Attribute(null, "autocreate", __obj.autocreate.toString, attr)
      if (__obj.generate.toString != "true") attr = scala.xml.Attribute(null, "generate", __obj.generate.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.RelationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  trait DefaultItemsRelationsTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.RelationsType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("relationsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.RelationsType] =
      phrase(rep(scalaxb.ElemName(None, "relation")) ^^
      { case p1 =>
      com.nekopiano.scala.scalaxb.y.items.RelationsType(p1.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.RelationType](_, scalaxb.ElemName(node) :: stack) }: _*) })
    
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.RelationsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.relation flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.RelationType](_, None, Some("relation"), __scope, false) })
  }

  def buildItemsCardinalityFormat = new DefaultItemsCardinalityFormat {}
  trait DefaultItemsCardinalityFormat extends scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.Cardinality] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.nekopiano.scala.scalaxb.y.items.Cardinality] = seq match {
      case elem: scala.xml.Elem => Right(com.nekopiano.scala.scalaxb.y.items.Cardinality.fromString(elem.text, elem.scope))
      case _ => Right(com.nekopiano.scala.scalaxb.y.items.Cardinality.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.nekopiano.scala.scalaxb.y.items.Cardinality, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }
  def buildItemsCollectiontypeFormat = new DefaultItemsCollectiontypeFormat {}
  trait DefaultItemsCollectiontypeFormat extends scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.Collectiontype] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.nekopiano.scala.scalaxb.y.items.Collectiontype] = seq match {
      case elem: scala.xml.Elem => Right(com.nekopiano.scala.scalaxb.y.items.Collectiontype.fromString(elem.text, elem.scope))
      case _ => Right(com.nekopiano.scala.scalaxb.y.items.Collectiontype.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.nekopiano.scala.scalaxb.y.items.Collectiontype, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }
  trait DefaultItemsRelationElementTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.RelationElementType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("relationElementType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.RelationElementType] =
      phrase(opt(scalaxb.ElemName(None, "description")) ~ 
      opt(scalaxb.ElemName(None, "modifiers")) ~ 
      opt(scalaxb.ElemName(None, "model")) ~ 
      opt(scalaxb.ElemName(None, "custom-properties")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      com.nekopiano.scala.scalaxb.y.items.RelationElementType(p1.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.ModifiersType](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.AttributeModelType](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.CustomPropertiesType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@qualifier").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@metatype").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@cardinality").headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.Cardinality](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@navigable").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@collectiontype").headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.Collectiontype](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@ordered").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.RelationElementType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.qualifier foreach { x => attr = scala.xml.Attribute(null, "qualifier", x.toString, attr) }
      __obj.metatype foreach { x => attr = scala.xml.Attribute(null, "metatype", x.toString, attr) }
      __obj.cardinality foreach { x => attr = scala.xml.Attribute(null, "cardinality", x.toString, attr) }
      __obj.navigable foreach { x => attr = scala.xml.Attribute(null, "navigable", x.toString, attr) }
      __obj.collectiontype foreach { x => attr = scala.xml.Attribute(null, "collectiontype", x.toString, attr) }
      __obj.ordered foreach { x => attr = scala.xml.Attribute(null, "ordered", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.RelationElementType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.description map { scalaxb.toXML[String](_, None, Some("description"), __scope, false) } getOrElse {Nil},
        __obj.modifiers map { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.ModifiersType](_, None, Some("modifiers"), __scope, false) } getOrElse {Nil},
        __obj.model map { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.AttributeModelType](_, None, Some("model"), __scope, false) } getOrElse {Nil},
        __obj.customu45properties map { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.CustomPropertiesType](_, None, Some("custom-properties"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultItemsEnumtypeTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.EnumtypeType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("enumtypeType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.EnumtypeType] =
      phrase(opt(scalaxb.ElemName(None, "description")) ~ 
      opt(scalaxb.ElemName(None, "model")) ~ 
      rep(scalaxb.ElemName(None, "value")) ^^
      { case p1 ~ p2 ~ p3 =>
      com.nekopiano.scala.scalaxb.y.items.EnumtypeType(p1.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.EnumModelType](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.EnumValueType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@code"), scalaxb.ElemName(node) :: stack),
        (node \ "@autocreate").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack) },
        (node \ "@generate").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack) },
        (node \ "@jaloclass").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@dynamic").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.EnumtypeType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "code", __obj.code.toString, attr)
      if (__obj.autocreate.toString != "true") attr = scala.xml.Attribute(null, "autocreate", __obj.autocreate.toString, attr)
      if (__obj.generate.toString != "true") attr = scala.xml.Attribute(null, "generate", __obj.generate.toString, attr)
      __obj.jaloclass foreach { x => attr = scala.xml.Attribute(null, "jaloclass", x.toString, attr) }
      __obj.dynamic foreach { x => attr = scala.xml.Attribute(null, "dynamic", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.EnumtypeType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.description map { scalaxb.toXML[String](_, None, Some("description"), __scope, false) } getOrElse {Nil},
        __obj.model map { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.EnumModelType](_, None, Some("model"), __scope, false) } getOrElse {Nil},
        __obj.value flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.EnumValueType](_, None, Some("value"), __scope, false) })

  }

  trait DefaultItemsEnumtypesTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.EnumtypesType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("enumtypesType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.EnumtypesType] =
      phrase(rep(scalaxb.ElemName(None, "enumtype")) ^^
      { case p1 =>
      com.nekopiano.scala.scalaxb.y.items.EnumtypesType(p1.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.EnumtypeType](_, scalaxb.ElemName(node) :: stack) }: _*) })
    
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.EnumtypesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.enumtype flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.EnumtypeType](_, None, Some("enumtype"), __scope, false) })
  }

  trait DefaultItemsIndexTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.IndexType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("indexType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.IndexType] =
      phrase(rep(scalaxb.ElemName(None, "key")) ^^
      { case p1 =>
      com.nekopiano.scala.scalaxb.y.items.IndexType(p1.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.IndexKeyType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@name"), scalaxb.ElemName(node) :: stack),
        (node \ "@remove").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack) },
        (node \ "@replace").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack) },
        (node \ "@unique").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.IndexType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
      if (__obj.remove.toString != "false") attr = scala.xml.Attribute(null, "remove", __obj.remove.toString, attr)
      if (__obj.replace.toString != "false") attr = scala.xml.Attribute(null, "replace", __obj.replace.toString, attr)
      __obj.unique foreach { x => attr = scala.xml.Attribute(null, "unique", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.IndexType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.key flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.IndexKeyType](_, None, Some("key"), __scope, false) })
  }

  trait DefaultItemsIndexKeyTypeFormat extends scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.IndexKeyType] with scalaxb.CanWriteChildNodes[com.nekopiano.scala.scalaxb.y.items.IndexKeyType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.nekopiano.scala.scalaxb.y.items.IndexKeyType] = seq match {
      case node: scala.xml.Node => Right(com.nekopiano.scala.scalaxb.y.items.IndexKeyType(scalaxb.fromXML[String]((node \ "@attribute"), scalaxb.ElemName(node) :: stack),
        (node \ "@lower").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.IndexKeyType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "attribute", __obj.attribute.toString, attr)
      __obj.lower foreach { x => attr = scala.xml.Attribute(null, "lower", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.IndexKeyType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultItemsAttributeTypeFormat extends scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.AttributeType] with scalaxb.CanWriteChildNodes[com.nekopiano.scala.scalaxb.y.items.AttributeType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.nekopiano.scala.scalaxb.y.items.AttributeType] = seq match {
      case node: scala.xml.Node => Right(com.nekopiano.scala.scalaxb.y.items.AttributeType((node \ "defaultvalue").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "description").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "persistence").headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.PersistenceType](_, scalaxb.ElemName(node) :: stack) },
        (node \ "modifiers").headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.ModifiersType](_, scalaxb.ElemName(node) :: stack) },
        (node \ "custom-properties").headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.CustomPropertiesType](_, scalaxb.ElemName(node) :: stack) },
        (node \ "model").headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.AttributeModelType](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@redeclare").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@qualifier"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@metatype").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@autocreate").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack) },
        (node \ "@generate").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack) },
        (node \ "@isSelectionOf").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.AttributeType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.redeclare foreach { x => attr = scala.xml.Attribute(null, "redeclare", x.toString, attr) }
      attr = scala.xml.Attribute(null, "qualifier", __obj.qualifier.toString, attr)
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.metatype foreach { x => attr = scala.xml.Attribute(null, "metatype", x.toString, attr) }
      if (__obj.autocreate.toString != "true") attr = scala.xml.Attribute(null, "autocreate", __obj.autocreate.toString, attr)
      if (__obj.generate.toString != "true") attr = scala.xml.Attribute(null, "generate", __obj.generate.toString, attr)
      __obj.isSelectionOf foreach { x => attr = scala.xml.Attribute(null, "isSelectionOf", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.AttributeType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.defaultvalue map { scalaxb.toXML[String](_, None, Some("defaultvalue"), __scope, false) } getOrElse {Nil},
        __obj.description map { scalaxb.toXML[String](_, None, Some("description"), __scope, false) } getOrElse {Nil},
        __obj.persistence map { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.PersistenceType](_, None, Some("persistence"), __scope, false) } getOrElse {Nil},
        __obj.modifiers map { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.ModifiersType](_, None, Some("modifiers"), __scope, false) } getOrElse {Nil},
        __obj.customu45properties map { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.CustomPropertiesType](_, None, Some("custom-properties"), __scope, false) } getOrElse {Nil},
        __obj.model map { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.AttributeModelType](_, None, Some("model"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultItemsAttributeModelTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.AttributeModelType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("attributeModelType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.AttributeModelType] =
      phrase(rep(scalaxb.ElemName(None, "getter")) ~ 
      rep(scalaxb.ElemName(None, "setter")) ^^
      { case p1 ~ p2 =>
      com.nekopiano.scala.scalaxb.y.items.AttributeModelType(p1.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.ModelMethodType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.ModelMethodType](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@generate").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.AttributeModelType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      if (__obj.generate.toString != "true") attr = scala.xml.Attribute(null, "generate", __obj.generate.toString, attr)
      attr
    }
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.AttributeModelType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.getter flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.ModelMethodType](_, None, Some("getter"), __scope, false) },
        __obj.setter flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.ModelMethodType](_, None, Some("setter"), __scope, false) })

  }

  trait DefaultItemsItemModelTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.ItemModelType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("itemModelType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.ItemModelType] =
      phrase(rep(scalaxb.ElemName(None, "constructor")) ^^
      { case p1 =>
      com.nekopiano.scala.scalaxb.y.items.ItemModelType(p1.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.ModelConstructorType](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@generate").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.ItemModelType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      if (__obj.generate.toString != "true") attr = scala.xml.Attribute(null, "generate", __obj.generate.toString, attr)
      attr
    }
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.ItemModelType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.constructor flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.ModelConstructorType](_, None, Some("constructor"), __scope, false) })
  }

  trait DefaultItemsModelConstructorTypeFormat extends scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.ModelConstructorType] with scalaxb.CanWriteChildNodes[com.nekopiano.scala.scalaxb.y.items.ModelConstructorType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.nekopiano.scala.scalaxb.y.items.ModelConstructorType] = seq match {
      case node: scala.xml.Node => Right(com.nekopiano.scala.scalaxb.y.items.ModelConstructorType(scalaxb.fromXML[String]((node \ "@signature"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.ModelConstructorType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "signature", __obj.signature.toString, attr)
      attr
    }
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.ModelConstructorType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }
  trait DefaultItemsModelMethodTypeFormat extends scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.ModelMethodType] with scalaxb.CanWriteChildNodes[com.nekopiano.scala.scalaxb.y.items.ModelMethodType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.nekopiano.scala.scalaxb.y.items.ModelMethodType] = seq match {
      case node: scala.xml.Node => Right(com.nekopiano.scala.scalaxb.y.items.ModelMethodType(scalaxb.fromXML[String]((node \ "@name"), scalaxb.ElemName(node) :: stack),
        (node \ "@deprecated").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack) },
        (node \ "@default").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("false"), scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.ModelMethodType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
      if (__obj.deprecated.toString != "false") attr = scala.xml.Attribute(null, "deprecated", __obj.deprecated.toString, attr)
      if (__obj.default.toString != "false") attr = scala.xml.Attribute(null, "default", __obj.default.toString, attr)
      attr
    }

    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.ModelMethodType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultItemsCustomPropertiesTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.CustomPropertiesType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("customPropertiesType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.CustomPropertiesType] =
      phrase(rep(scalaxb.ElemName(None, "property")) ^^
      { case p1 =>
      com.nekopiano.scala.scalaxb.y.items.CustomPropertiesType(p1.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.CustomPropertyType](_, scalaxb.ElemName(node) :: stack) }: _*) })
    
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.CustomPropertiesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.property flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.CustomPropertyType](_, None, Some("property"), __scope, false) })
  }

  trait DefaultItemsCustomPropertyTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.CustomPropertyType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("customPropertyType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.CustomPropertyType] =
      phrase((scalaxb.ElemName(None, "value")) ^^
      { case p1 =>
      com.nekopiano.scala.scalaxb.y.items.CustomPropertyType(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@name"), scalaxb.ElemName(node) :: stack)) })
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.CustomPropertyType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
      attr
    }
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.CustomPropertyType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[String](__obj.value, None, Some("value"), __scope, false))
  }

  trait DefaultItemsAttributesTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.AttributesType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("attributesType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.AttributesType] =
      phrase(rep(scalaxb.ElemName(None, "attribute")) ^^
      { case p1 =>
      com.nekopiano.scala.scalaxb.y.items.AttributesType(p1.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.AttributeType](_, scalaxb.ElemName(node) :: stack) }: _*) })
    
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.AttributesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.attribute flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.AttributeType](_, None, Some("attribute"), __scope, false) })
  }

  trait DefaultItemsIndexesTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.IndexesType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("indexesType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.IndexesType] =
      phrase(rep(scalaxb.ElemName(None, "index")) ^^
      { case p1 =>
      com.nekopiano.scala.scalaxb.y.items.IndexesType(p1.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.IndexType](_, scalaxb.ElemName(node) :: stack) }: _*) })
    
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.IndexesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.index flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.IndexType](_, None, Some("index"), __scope, false) })
  }

  trait DefaultItemsItemtypeTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.ItemtypeType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("itemtypeType")

    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.ItemtypeType] =
      phrase(optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "description")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "deployment")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.DeploymentType](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "custom-properties")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.CustomPropertiesType](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "attributes")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.AttributesType](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "indexes")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.IndexesType](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ~ 
      (opt(scalaxb.ElemName(None, "model")) ^^ 
      (_ map { x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.ItemModelType](x, scalaxb.ElemName(node) :: stack)) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 ~ p13 =>
      com.nekopiano.scala.scalaxb.y.items.ItemtypeType(Seq.concat(p1.toList,
        p2.toList,
        p3.toList,
        p4.toList,
        p5.toList,
        p6.toList,
        p7.toList,
        p8.toList,
        p9.toList,
        p10.toList,
        p11.toList,
        p12.toList,
        p13.toList),
        scalaxb.fromXML[String]((node \ "@code"), scalaxb.ElemName(node) :: stack),
        (node \ "@extends").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@jaloclass").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@deployment").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@singleton").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@jaloonly").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@autocreate").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack) },
        (node \ "@generate").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack) },
        (node \ "@abstract").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@metatype").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.ItemtypeType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "code", __obj.code.toString, attr)
      __obj.extendsValue foreach { x => attr = scala.xml.Attribute(null, "extends", x.toString, attr) }
      __obj.jaloclass foreach { x => attr = scala.xml.Attribute(null, "jaloclass", x.toString, attr) }
      __obj.deployment foreach { x => attr = scala.xml.Attribute(null, "deployment", x.toString, attr) }
      __obj.singleton foreach { x => attr = scala.xml.Attribute(null, "singleton", x.toString, attr) }
      __obj.jaloonly foreach { x => attr = scala.xml.Attribute(null, "jaloonly", x.toString, attr) }
      if (__obj.autocreate.toString != "true") attr = scala.xml.Attribute(null, "autocreate", __obj.autocreate.toString, attr)
      if (__obj.generate.toString != "true") attr = scala.xml.Attribute(null, "generate", __obj.generate.toString, attr)
      __obj.abstractValue foreach { x => attr = scala.xml.Attribute(null, "abstract", x.toString, attr) }
      __obj.metatype foreach { x => attr = scala.xml.Attribute(null, "metatype", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.ItemtypeType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }
  }

  trait DefaultItemsItemtypesTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.ItemtypesType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("itemtypesType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.ItemtypesType] =
      phrase(rep(scalaxb.ElemName(None, "itemtype")) ~ 
      rep(scalaxb.ElemName(None, "typegroup")) ^^
      { case p1 ~ p2 =>
      com.nekopiano.scala.scalaxb.y.items.ItemtypesType(p1.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.ItemtypeType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.TypeGroupType](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.ItemtypesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.itemtype flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.ItemtypeType](_, None, Some("itemtype"), __scope, false) },
        __obj.typegroup flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.TypeGroupType](_, None, Some("typegroup"), __scope, false) })

  }

  trait DefaultItemsTypeGroupTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.TypeGroupType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("typeGroupType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.TypeGroupType] =
      phrase(rep(scalaxb.ElemName(None, "itemtype")) ^^
      { case p1 =>
      com.nekopiano.scala.scalaxb.y.items.TypeGroupType(p1.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.ItemtypeType](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@name").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.TypeGroupType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.TypeGroupType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.itemtype flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.ItemtypeType](_, None, Some("itemtype"), __scope, false) })
  }

  trait DefaultItemsItemsFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.Items] {
    val targetNamespace: Option[String] = None
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.Items] =
      phrase(opt(scalaxb.ElemName(None, "atomictypes")) ~ 
      opt(scalaxb.ElemName(None, "collectiontypes")) ~ 
      opt(scalaxb.ElemName(None, "enumtypes")) ~ 
      opt(scalaxb.ElemName(None, "maptypes")) ~ 
      opt(scalaxb.ElemName(None, "relations")) ~ 
      opt(scalaxb.ElemName(None, "itemtypes")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      com.nekopiano.scala.scalaxb.y.items.Items(p1.headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.AtomictypesType](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.CollectiontypesType](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.EnumtypesType](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.MaptypesType](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.RelationsType](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.ItemtypesType](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.Items, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.atomictypes map { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.AtomictypesType](_, None, Some("atomictypes"), __scope, false) } getOrElse {Nil},
        __obj.collectiontypes map { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.CollectiontypesType](_, None, Some("collectiontypes"), __scope, false) } getOrElse {Nil},
        __obj.enumtypes map { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.EnumtypesType](_, None, Some("enumtypes"), __scope, false) } getOrElse {Nil},
        __obj.maptypes map { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.MaptypesType](_, None, Some("maptypes"), __scope, false) } getOrElse {Nil},
        __obj.relations map { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.RelationsType](_, None, Some("relations"), __scope, false) } getOrElse {Nil},
        __obj.itemtypes map { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.ItemtypesType](_, None, Some("itemtypes"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultItemsMaptypeTypeFormat extends scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.MaptypeType] with scalaxb.CanWriteChildNodes[com.nekopiano.scala.scalaxb.y.items.MaptypeType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.nekopiano.scala.scalaxb.y.items.MaptypeType] = seq match {
      case node: scala.xml.Node => Right(com.nekopiano.scala.scalaxb.y.items.MaptypeType(scalaxb.fromXML[String]((node \ "@code"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@argumenttype"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@returntype"), scalaxb.ElemName(node) :: stack),
        (node \ "@autocreate").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack) },
        (node \ "@generate").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[Boolean](scala.xml.Text("true"), scalaxb.ElemName(node) :: stack) },
        (node \ "@redeclare").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.MaptypeType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "code", __obj.code.toString, attr)
      attr = scala.xml.Attribute(null, "argumenttype", __obj.argumenttype.toString, attr)
      attr = scala.xml.Attribute(null, "returntype", __obj.returntype.toString, attr)
      if (__obj.autocreate.toString != "true") attr = scala.xml.Attribute(null, "autocreate", __obj.autocreate.toString, attr)
      if (__obj.generate.toString != "true") attr = scala.xml.Attribute(null, "generate", __obj.generate.toString, attr)
      __obj.redeclare foreach { x => attr = scala.xml.Attribute(null, "redeclare", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.MaptypeType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  trait DefaultItemsMaptypesTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.MaptypesType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("maptypesType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.MaptypesType] =
      phrase(rep(scalaxb.ElemName(None, "maptype")) ^^
      { case p1 =>
      com.nekopiano.scala.scalaxb.y.items.MaptypesType(p1.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.MaptypeType](_, scalaxb.ElemName(node) :: stack) }: _*) })
    
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.MaptypesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.maptype flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.MaptypeType](_, None, Some("maptype"), __scope, false) })
  }

  trait DefaultItemsModifiersTypeFormat extends scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.ModifiersType] with scalaxb.CanWriteChildNodes[com.nekopiano.scala.scalaxb.y.items.ModifiersType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.nekopiano.scala.scalaxb.y.items.ModifiersType] = seq match {
      case node: scala.xml.Node => Right(com.nekopiano.scala.scalaxb.y.items.ModifiersType((node \ "@read").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@write").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@search").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@optional").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@private").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@initial").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@removable").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@partof").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@unique").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@dontOptimize").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@encrypted").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.ModifiersType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.read foreach { x => attr = scala.xml.Attribute(null, "read", x.toString, attr) }
      __obj.write foreach { x => attr = scala.xml.Attribute(null, "write", x.toString, attr) }
      __obj.search foreach { x => attr = scala.xml.Attribute(null, "search", x.toString, attr) }
      __obj.optional foreach { x => attr = scala.xml.Attribute(null, "optional", x.toString, attr) }
      __obj.privateValue foreach { x => attr = scala.xml.Attribute(null, "private", x.toString, attr) }
      __obj.initial foreach { x => attr = scala.xml.Attribute(null, "initial", x.toString, attr) }
      __obj.removable foreach { x => attr = scala.xml.Attribute(null, "removable", x.toString, attr) }
      __obj.partof foreach { x => attr = scala.xml.Attribute(null, "partof", x.toString, attr) }
      __obj.unique foreach { x => attr = scala.xml.Attribute(null, "unique", x.toString, attr) }
      __obj.dontOptimize foreach { x => attr = scala.xml.Attribute(null, "dontOptimize", x.toString, attr) }
      __obj.encrypted foreach { x => attr = scala.xml.Attribute(null, "encrypted", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.ModifiersType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }

  def buildItemsTypeTypeFormat = new DefaultItemsTypeTypeFormat {}
  trait DefaultItemsTypeTypeFormat extends scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.TypeType] {
    val targetNamespace: Option[String] = None
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.nekopiano.scala.scalaxb.y.items.TypeType] = seq match {
      case elem: scala.xml.Elem => Right(com.nekopiano.scala.scalaxb.y.items.TypeType.fromString(elem.text, elem.scope))
      case _ => Right(com.nekopiano.scala.scalaxb.y.items.TypeType.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: com.nekopiano.scala.scalaxb.y.items.TypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }
  trait DefaultItemsPersistenceTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.PersistenceType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("persistenceType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.PersistenceType] =
      phrase(rep(scalaxb.ElemName(None, "columntype")) ^^
      { case p1 =>
      com.nekopiano.scala.scalaxb.y.items.PersistenceType(p1.toSeq map { scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.ColumntypeType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[com.nekopiano.scala.scalaxb.y.items.TypeType]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@qualifier").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@attributeHandler").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.PersistenceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.qualifier foreach { x => attr = scala.xml.Attribute(null, "qualifier", x.toString, attr) }
      __obj.attributeHandler foreach { x => attr = scala.xml.Attribute(null, "attributeHandler", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.PersistenceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.columntype flatMap { scalaxb.toXML[com.nekopiano.scala.scalaxb.y.items.ColumntypeType](_, None, Some("columntype"), __scope, false) })
  }

  trait DefaultItemsColumntypeTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.ColumntypeType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("columntypeType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.ColumntypeType] =
      phrase((scalaxb.ElemName(None, "value")) ^^
      { case p1 =>
      com.nekopiano.scala.scalaxb.y.items.ColumntypeType(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
        (node \ "@database").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.ColumntypeType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.database foreach { x => attr = scala.xml.Attribute(null, "database", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.ColumntypeType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[String](__obj.value, None, Some("value"), __scope, false))
  }

  trait DefaultItemsValueTypeFormat extends scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.ValueType] with scalaxb.CanWriteChildNodes[com.nekopiano.scala.scalaxb.y.items.ValueType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.nekopiano.scala.scalaxb.y.items.ValueType] = seq match {
      case node: scala.xml.Node => Right(com.nekopiano.scala.scalaxb.y.items.ValueType(scalaxb.fromXML[String]((node \ "@code"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.ValueType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "code", __obj.code.toString, attr)
      attr
    }
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.ValueType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }
  trait DefaultItemsEnumModelTypeFormat extends scalaxb.XMLFormat[com.nekopiano.scala.scalaxb.y.items.EnumModelType] with scalaxb.CanWriteChildNodes[com.nekopiano.scala.scalaxb.y.items.EnumModelType] {
    val targetNamespace: Option[String] = None
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, com.nekopiano.scala.scalaxb.y.items.EnumModelType] = seq match {
      case node: scala.xml.Node => Right(com.nekopiano.scala.scalaxb.y.items.EnumModelType((node \ "@package").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.EnumModelType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.packageValue foreach { x => attr = scala.xml.Attribute(null, "package", x.toString, attr) }
      attr
    }
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.EnumModelType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil

  }
  trait DefaultItemsEnumValueTypeFormat extends scalaxb.ElemNameParser[com.nekopiano.scala.scalaxb.y.items.EnumValueType] {
    val targetNamespace: Option[String] = None
    
    override def typeName: Option[String] = Some("enumValueType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[com.nekopiano.scala.scalaxb.y.items.EnumValueType] =
      phrase(opt(scalaxb.ElemName(None, "description")) ^^
      { case p1 =>
      com.nekopiano.scala.scalaxb.y.items.EnumValueType(p1.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@code"), scalaxb.ElemName(node) :: stack)) })
    
    override def writesAttribute(__obj: com.nekopiano.scala.scalaxb.y.items.EnumValueType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "code", __obj.code.toString, attr)
      attr
    }
    def writesChildNodes(__obj: com.nekopiano.scala.scalaxb.y.items.EnumValueType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.description map { scalaxb.toXML[String](_, None, Some("description"), __scope, false) } getOrElse {Nil})
  }


}

